IMPORT "java7.dtd" AS s
IMPORT "java8.dtd" AS v

$source = doc("example1InJava7.xml")
$viewce = doc("example1InJava8.xml")

START = updateCompilationUnit($source/compilationUnit, $view/compilationUnit)

PROCEDURE updateCompilationUnit(source $src AS s:compilationUnit, view $view AS v:compilationUnit) =
UPDATE compilationUnit
       [$sPackageDeclaration AS s:packageDeclaration?, $sImportDeclarations AS s:importDeclaration*, $sTypeDeclarations AS s:typeDeclaration*] IN $src BY
{
	updatePackageDeclarationQ($sPackageDeclaration, $vPackageDeclaration);
	updateImportDeclarations($sImportDeclarations, $vImportDeclarations);
	updateTypeDeclarations($sTypeDeclarations, $vTypeDeclarations)
}
FOR VIEW compilationUnit[$vPackageDeclaration AS v:packageDeclaration?, $vImportDeclarations AS v:importDeclaration*, $vTypeDeclarations AS v:typeDeclaration*] IN $view

(:-------------------------Declaration----------------------------:)

PROCEDURE updatePackageDeclarationQ(source $src AS s:packageDeclaration?, view $view AS v:packageDeclaration?) =
UPDATE $sPackageDeclaration IN $src BY
{
	MATCH -> updatePackageDeclaration($sPackageDeclaration, $vPackageDeclaration)
	| UNMATCHS -> DELETE .
	| UNMATCHV -> CREATE VALUE <packageDeclaration>
					<packageName>
						<identifier/>
					</packageName>
				   </packageDeclaration>
}
FOR VIEW $vPackageDeclaration IN $view

PROCEDURE updatePackageDeclaration(source $src AS s:packageDeclaration, view $view AS v:packageDeclaration) =
UPDATE packageDeclaration[$sPackageName AS s:packageName] IN $src BY
{
	updatePackageName($sPackageName, $vPackageName)
}
FOR VIEW packageDeclaration[$vPackageName AS v:packageName] IN $view

PROCEDURE updateImportDeclaration(source $src AS s:importDeclaration, view $view AS v:importDeclaration) =
UPDATE importDeclaration[$sDeclaration AS (s:singleTypeImportDeclaration | s:typeImportOnDemandDeclaration)] IN $src BY
{
	 CASE $sDeclaration OF
	{
		$sSingleTypeImportDeclaration AS s:SingleTypeImportDeclaration 
		-> CASE $vDeclaration OF
		{
			$vSingleTypeImportDeclaration AS v:SingleTypeImportDeclaration 
			-> updateSingleTypeImportDeclration ($sSingleTypeImportDeclaration, $vSingleTypeImportDeclaration)
			| $vTypeImportOnDemandDeclaration AS v:typeImportOnDemandDeclaration
			-> DELETE . ;
			CREATE VALUE <typeImportOnDemandDeclaration>
					<packageName>
						<identifier/>
					</packageName>
			       	     </typeImportOnDemandDeclaration>
		}
		| $sTypeImportOnDemandDeclaration AS s:typeImportOnDemandDeclaration
		-> CASE $vDeclaration OF
		{
			$vSingleTypeImportDeclaration AS v:SingleTypeImportDeclaration
			-> DELETE . ; 
			CREATE VALUE <singleTypeImportDeclaration>
					<typeName>
						<packageName>
							<idnetifier/>
						</packageName>
						<identifier/>
					</typeName>
			       	     </singleTypeImportDeclaration>
			| $vTypeImportOnDemandDeclaration AS v:typeImportOnDemandDeclaration
			-> updateTypeImportOnDemandDeclaration ($sTypeImportOnDemandDeclaration, $vTypeImportOnDemandDeclaration) 
		}
	}
}
FOR VIEW importDeclaration[$vDeclaration AS (s:singleTypeImportDeclaration | s:typeImportOnDemandDeclaration)] IN $view

PROCEDURE updateImportDeclarations(source $src AS s:importDeclaration*, view $view AS v:importDeclaration*) =
UPDATE $sImportDeclaration IN $src BY
{
	MATCH -> upadateImportDeclaration($sImportDeclaration, $vImportDeclaration)
	| UNMATCHV -> CASE $vImportDeclaration OF
	{
		v:TypeImportOnDemandDeclaration -> CREATE VALUE <typeImportOnDemandDeclaration>
									<packageName>
										<identifier/>
									/packageName>
			       	     				</typeImportOnDemandDeclaration>
		v:singleTypeImportDeclaration -> CREATE VALUE <singleTypeImportDeclaration>
								<typeName>
									<packageName>
										<idnetifier/>
									</packageName>
									<identifier/>
								</typeName>
			       	     			      </singleTypeImportDeclaration>
	}
}
FOR VIEW $vImportDeclaration IN $view

PROCEDURE updateSingleTypeImportDeclaration(source $src AS s:singleTypeImportDeclaration, view $view AS v:singTypeImportDeclaration) =
UPDATE singleTypeImportDeclaration[$sTypeName AS s:typeName] IN $src BY
{
	upadateTypeName($sTypeName, $vTypeName)
}
FOR VIEW singleTypeImportDeclaration[$vTypeName AS v:typeName] IN $view

PROCEDURE updateTypeImportOnDemandDeclaration(source $src AS s:typeImportOnDemandDeclaration, view $view AS v:typeImportOnDemandDeclaration) =
UPDATE typeImportOnDemandDeclaration[$sPackageName AS s:packageName] IN $src BY
{
	updatePackageName($sPackageName, $vPackageName)
}
FOR VIEW typeImportOnDemandDeclaration[$vPackageName AS v:packageName] IN $view

PROCEDURE updateTypeDeclarations(source $src AS s:typeDeclaration*, view $view AS v:typeDeclaration*) =
UPDATE $sDeclaration IN $src BY
{
	MATCH -> updateTypeDeclaration($sDeclaration, $vDeclaration)
	| UNMATCHS -> DELETE .
	| UNMATCHV -> CASE $vDeclaration OF
	{
		$classDeclaration AS v:classDeclaration
		-> CREATE VALUE <classDeclaration>
					<identifier/>
					<classBodey>					
					</classBody>
				</classDeclaration>
		| $interfaceDeclaration AS v:interfaceDeclaration
		-> CREATE VALUE <interfaceDeclaration>
					<identifier/>
					<interfaceBodey>					
					</interfaceBody>
			       	</interfaceDeclaration>	
	}	
}
FOR VIEW $vDeclaration IN $view
MATCHING SOURCE BY $sDeclaration/identifier VIEW BY $vDeclaration/identifier 
(:Here matching by the name of class or interface:)

PROCEDURE updateTypeDeclaration(source $src AS s:typeDeclaration, view $view AS v:typeDeclaration) =
UPDATE $sDeclaration IN $src BY
{
	CASE $vDeclaration OF 
	{
		$vClassDeclaration AS v:classDeclaration 
		-> CASE $sDeclaration OF
		{
			$sClassDeclaration AS s:classDeclaration 
			-> updateClassDeclaration($sClassDeclaration, $vClassDeclaration)
			| $sInterfaceDeclaration AS s:InterfaceDeclaration
			-> DELETE . ;
			CREATE VALUE <classDeclaration>
					<identifier/>
					<classBody>
					</classBody>
		       	     	     </classDeclaration>
		}
		| $vInterfaceDeclaration AS v:interfaceDeclaration
		-> CASE $sDeclaration OF
		{
			$sClassDeclaration AS s:classDeclaration
			-> DELETE . ;
			CREATE VALUE <interfaceDeclaration>
					<identifier/>
					<interfaceBodey>					
					</interfaceBody>
		       	     		</interfaceDeclaration>
			| $sInterfaceDeclaration AS s:InterfaceDeclaration
			-> updateInterfaceDeclaration($sInterfaceDeclaration, $vInterfaceDeclaration)
		}
	}
}
FOR VIEW $vDeclaration IN $view 

PROCEDURE updateClassDeclaration(source $src AS s:classDeclaration, view $view AS v:classDeclaration) =
UPDATE classDeclaration[$sClassModifiers AS s:classModifier*, $sIdentifier AS s:identifier, $sSuper AS s:super?, $sInterfaceTypes AS s:interfaceType*, $sClassBody AS s:classBoody] IN $src BY
{
	updateClassModifiers($sClassModifiers, $vClassModifiers);
	updateIdentifier($sIdentifier, $vIdentifier);
	updateSuperQ($sSuper, $vSuper);
	updateInterfaceTypes($sInterfaceTypes, $vInterfaceTypes);
	updateClassBody($sClassBody, $vClassBody)
}
FOR VIEW classDeclaration[$vClassModifiers AS v:classModifier*, $vIdentifier AS v:identifier, $vSuper AS v:super?, $vInterfaceTypes AS v:interfaceType*, $vClassBody AS v:classBoody] IN $view

PROCEDURE updateClassModifiers(source $src AS s:classModifier*, view $view AS v:classModifier*) =
UPDATE $sModifier IN $src BY
{
	UNMATCHS -> DELETE .
	| UNMATCHV -> CREATE <classModifier/>
}
FOR VIEW $vModifier IN $view
MATCHING SOURCE BY $sModifier/text() VIEW BY $vModifier/text()

PROCDURE updateSuperQ(source $src AS s:super?, view $view AS v:super?) =
UPDATE $sSuper IN $src BY
{
	MATCH -> updateSuper($sSuper, $vSuper)
	| UNMATCHS -> DELETE .
	| UNMATCHV -> CREATE VALUE <super>
					<classType>
						<typeName>
							<identifier/>
						</typeName>
					</classType>
	  	      	     	   </super>
}
FOR VIEW $vSuper IN $view

PRORCEDURE updateSuper(source $src AS s:super, view $view AS v:super) =
UPDATE super[$sClassType AS s:classType] IN $src BY
{
	updateClassType($sClassType, $vClassType)
}
FOR VIEW super[$vClassType AS v:classType] IN $view

PROCEDURE updateClassBody(source $src AS s:classBody, view $view AS v:classBody) =
UPDATE classBody[$sClassBodyDeclarations AS s:classBodyDeclaration*] IN $src
{
	updateClassBodyDeclarations($sClassBodyDeclarations, $vClassBodyDeclarations)
}
FOR VIEW classBody[$vClassBodyDeclarations AS v:classBodyDeclaration*] IN $view 

PROCEDURE updateClassBodyDeclarations(source $src AS s:classBodyDeclaration*, view $view AS v:classBodyDeclaration*) =
UPDATE $sClassBodyDeclaration IN $src BY
{
	MATCH -> updateClassBodyDclaration($sClassBodyDeclaration, $vClassBodyDeclaration)
	UNMATCHS -> DELETE .
	UNMATCHV -> CASE $vDeclaration OF
	{
		$vFieldDeclaration AS v:fieldDeclaration 
		-> CREATE VALUE <classBodyDeclaration id = "">
					<fieldDeclaration>
						<tp>
							<primitiveType/>
						</tp>
						<variableDeclarator>
							<variableDeclaratorId>
								<identifier/>
								<dims/>
							</variableDeclaratorId>
						</variableDeclarator>
					</fieldDeclaration>
		   	  	</classBodyDeclaration>
		| $vMethodDeclaration As v:methodDeclaration 
		-> CREATE VALUE <classBodyDeclaration id = "">
					<methodDeclaration>
						<methodHeader>
							<resultType>
								<tp>
									<primitiveType/>
								</tp>
							</resultType>
							<methodDeclarator>
								<identifier/>
							</methodDeclarator>
						</methodHeader>
						<methodBody>
						</methodBody>
					</methodDeclaration>
		   	  	</classBodyDeclaration>
		| $vStaticInitializer AS v:staticIntialier 
		-> CREATE VALUE <classBodyDeclaration id = "">
					<staticInitializer>
						<block>	
						</block>
					</staticInitializer>
		   	  	</classBodyDeclaration>		
		| $vConstructorDeclaration AS v:constructorDeclaration 
		-> CREATE VALUE <classBodyDeclaration id = "">
					<constructorDeclaration>
						<constructorDeclarator>
							<simpleTypeName>
								<identifier/>
							</simpleTypeName>
						</constructorDeclarator>
						<constructorBody>
						</constructorBody>
					</constructorDeclaration>
		   	  	</classBodyDeclaration>
	} 
}
FOR VIEW $vClassBodyDeclaration IN $view
MATCHING SOURCE BY $sClassBodyDeclaration/@id/string() VIEW BY $vClassBodyDeclaration/@id/string()
(:Here we need to make sure that class body declarations of different type cannot have the same id:)

PROCEDURE updateClassBodyDeclaration(source $src AS s:classBodyDeclaration, view $view AS v:classBodyDeclaration) =
UPDATE classBodyDeclaration[@id[$sId AS String], $sDeclaration AS (s:fieldDeclaration | s:methodDeclaration | s:staticInitializer | s:constructorDeclaration)] IN $src BY
{
	REPLACE $sId WITH $vId;
	CASE $vDeclaration OF
	{
		$vFieldDeclaration AS v:fieldDeclaration -> CASE $sDeclaration OF 
		{
			$sFieldDeclaration AS s:fieldDeclaration
			-> updateFieldDeclaration($sFieldDeclaration, $vFieldDeclaration)
		}
		| $vMethodDeclaration As v:methodDeclaration -> CASE $sDeclaration OF
		{
			$sMethodDeclaration AS s:methodDeclaration
			-> updateMethodDeclaration($sMethodDeclaration, $vMethodDeclaration)
		}
		| $vStaticInitializer AS v:staticIntialier -> CASE $sDeclaration OF
		{
			$sStaticInitializer AS s:staticIntialier
			-> updateStaticInitializer($sStaticInitializer, $vStaticInitializer)
		}
		| $vConstructorDeclaration AS v:constructorDeclaration -> CASE $sDeclaration OF
		{
			$sConstructorDeclaration AS s:constructorDeclaration
			-> updateConstructorDeclaration($sConstructorDeclaration, $vConstructorDeclaration)
		}
	}
}
FOR VIEW classBodyDeclaration[@id[$vId AS String], $vDeclaration AS (v:fieldDeclaration | v:methodDeclaration | v:staticInitializer | v:constructorDeclaration)] IN $view

PROCEDURE updateStaticInitializer(source $src AS s:staticInitializer, view $view AS v:staticInitializer) =
UPDATE staticInitializer[$sBlock AS s:block] IN $src BY
{
	updateBlock($sBlock, $vBlock)
}
FOR VIEW staticInitializer[$vBlock AS v:block] IN VIEW

PROCEDURE updateConstructorDeclaration(source $src AS s:constructorDeclaration, view $view AS v:constructorDeclaration) =
UPDATE constructorDeclaration[$sConstructorModifiers AS s:constructorModifier*, $sConstructorDeclarator AS s:constructorDeclarator, $sThrows AS s:throws?, $sConstructorBody AS s:constructorBody] IN $src BY
{
	updateConstructorModifiers($sConstructorModifiers, $vConstructorModifiers);
	updateConstructorDeclarator($sConstructorDeclarator, $vConstructorDeclarator);
	updateThrowsQ($sThrows, $vThrows);
	updateConstructorBody($sConstructorBody, $vConstructorBody)
}
FOR VIEW constructorDeclaration[$vConstructorModifiers AS v:constructorModifier*, $vConstructorDeclarator AS v:constructorDeclarator, $vThrows AS v:throws?, $vConstructorBody AS v:constructorBody] IN $view 

PROCEDURE updateConstructorModifiers(source $src AS s:constructorModifier*, view $view AS v:constructorModifier*) =
UPDATE $sModifier IN $src BY
{
	UNMATCHV -> CREATE VALUE <constructorModifier/>
}
FOR VIEW $vModifier IN $view
MATCHING SOURCE BY $sModifier/text() VIEW BY $vModifier/text()

PROCEDURE updateConstructorDeclarator(source $src AS s:constructorDeclarator, view $view AS v:constructorDeclarator) =
UPDATE constructorDeclarator[$sSimpleTypeName AS s:simpleTypeName, $sFormalParameters AS s:formalParameter*] IN $src BY
{
	updateSimpleTypeName($sSimpleTypeName, $vSimpleTypeName);
	updateFormalParameter($sFormalParameters, $vFormalParameters)
}
FOR VIEW constructorDeclarator[$vSimpleTypeName AS v:simpleTypeName, $vForMalParameters AS v:formalParameter*] IN $view

PROCEDURE updateFormalParameters(source $src AS s:formalParameter*, view $view AS v:formalParameter*) =
UPDATE $sFormalParameter IN $src BY
{
	MATCH -> upadatFormalParameter($sFormalParameter, $vFormalParameter)
	| UNMATCHV -> CREATE VALUE <formalParameter>
					<tp>
						<primitiveType/>
					</tp>
					<variableDeclaratorId>
						<identifier/>
						<dims/>
					</variableDeclaratorId>
		    	   	 </formalParameter>
}
FOR VIEW $vFormalParameter IN $view
MATCHING SOURCE BY $sFormalParameter/identifier/text() VIEW BY $vFormalParameter/identifier/text()

PROCEDURE updateFormalParameter(source $src AS s:formalParameter, view $view AS v:formalParameter) =
UPDATE formalParameter[$sTp AS s:tp, variableDeclaratorId[$sIdentifier As s:identifier, $sDims AS s:dims]] IN $src BY
{
	updateTp($sTp, $vTp);
	updateString($sIdentifier/text(), $vIdentifier/text());
	updateString($sDims/text(), $vDims/text())
}
FOR VIEW formalParameter[$vTp AS v:tp, variableDeclaratorId[$vIdentifier AS v:idenfifier, $vDims AS v:dims]] IN $view

PROCEDURE updateThrowsQ(source $src AS s:throws?, view $view AS v:throws?) =
UPDATE $sThrows IN $src BY
{
	MATCH -> updateThrows($sThrows, $vThrows)
	| UNMATCHV -> CREATE VALUE <throws>
	  	      	     	   </throws>
}
FOR VIEW $vThrows IN $view

PROCEDURE updateThrows(source $src AS s:throws, view $view AS v:throws) =
UPDATE throws[$sClassTypes AS s:classType*] IN $src BY
{
	updateClassType($sClassTypes, $vClassTypes*)
}
FOR VIEW throws[$vClassTypes AS v:classType*] IN $view

PROCEDURE updateConstructorBody(source $src AS s:constructorBody, view $view As v:constructorBody) =
UPDATE constructorBody[$sExplicitConstructorInvocation AS s:explicitConstructorInvocation?, $sStatements AS s:statement*] IN $src BY
{
	updateExplicitConstructorInvocationQ($sExplicitConstructorInvocation, $vExplicitConstructorInvocation);
	updateStatement($sStatements, $vStatments)
}
FOR VIEW constructorBody[$vExplicitConstructorInvocation AS v:explicitConstructorInvocation?, $vStatement AS v:statement*] IN $view

PROCEDURE updateExplicitConstructorInvocationQ(source $src AS s:explicitConstructorInvocation?, view $view AS v:explicitConstructorInvocation?) =
UPDATE $sExplicitConstructorInvocation IN $src BY
{
	MATCH -> updateExplicitConstructorInvocation($sExplicitConstructorInvocation, $vExplicitConstructorInvocation)
	| UNMATCHV -> CREATE VALUE <explicitConstructorInvcation>
					<invocationKind/>
	  	      	     	   </explicitConstructorInvcation>
}
FOR VIEW $vExplicitConstructorInvocation IN $view

PROCEDURE updateExplicitConstructorInvocation(source $src AS s:explicitConstructorInvocation, view $view AS v:explicitConstructorInvocation) =
UPDATE explicitConstructorInvocation[$sInvocationKind AS s:invocationKind, $sArguments AS s:argument*] IN $src BY
{
	updateString($sInvocationKind/text(), $vInvocationKind/text());
	updateArguments($sArguments, $vArguments)
}
FOR VIEW explicitConstructorInvocation[$vInvocationKind As v:invocationKind, $vArguments AS v:argument*] IN $view

PROCEDURE updateArguments(source $src AS s:argument*, view $view AS v:argument*) =
UPDATE $sArguement IN $src BY
{
	MATCH -> updateArgument($sArgument, $vArgument)
	| UNMATCHV -> CREATE VALUE
	<argument>
	 <expression>
	  <assignmentExpression>
	   <conditionalExpression>
	    <conditionalOrExpression>
	     <conditionalAndExpression>
	      <inclusiveOrExpression>
	       <exclusiveOrExpression>
	        <andExpression>
	         <equalityExpression>
		  <relationalExpression>
		   <shiftExpression>
		    <additiveExpression>	
		     <mutiplicativeExpression>
		      <unaryExpression>
		       <unaryExpressionNotPlusMinus>
		        <postfixExpression>
			 <expressionName>
			  <identifier/>
			 </expressionName>
			</postfixExpression>
		       </unaryExpressionNotPlusMinus>
		      </unaryExpression>
		     </mutiplicativeExpression>
		    </additiveExpression>
		   </shiftExpression>
		  </ralationalExpression>
	         </equalityExpression>
		</andExpression>
	       </exclusiveOrExpression>
	      </inclusiveOrExpression>
	     </conditionalAndExpression>
	    </conditionalOrExpression>
	   </conditionalExpression>
	  </assignmentExpression>
	 </expression>
	</argument> 
}
FOR VIEW $vArgument IN $view


PROCEDURE updateFieldDeclaration(source $src AS s:fieldDeclaration, view $view AS v:fieldDeclaration) =
UPDATE fieldDeclaration[$sFieldModifiers AS s:fieldModifier*, $sTp AS s:tp, $sVariableDeclarators AS s:variableDeclarator+] IN $src BY
{
	updateFieldModifiers($sFieldModifiers, $vFieldModifiers);
	updateTp($sTp, $vTp);
	updateVariableDeclarators($sVariableDeclarators, $vVariableDeclarators)
}
FOR VIEW fieldDeclaration[$vFieldModifiers AS v:fieldModifier*, $vTp AS v:tp, $vVariableDeclarators AS v:variableDeclarator+] IN $view

PROCEDURE updateFieldModifiers(source $src AS s:fieldModifier*, view $view AS v:fieldModifier*) =
UPDATE $sModifier IN $src BY
{
	UNMATCHV -> CREATE VALUE <fieldModifier/>
}
FOR VIEW $vModifier IN $view
MATCHING SOURCE BY $sModifier/text() VIEW BY $vModifier/text()

PROCEDURE updateVariableDeclarators(source $src AS s:variableDeclarator+, view $view AS v:variableDeclarator+) =
UPDATE $sVariableDeclarator IN $src BY
{
	MATCH -> updateVariableDeclarator($sVariableDeclarator, $vVariableDeclarator)
	| UNMATCHV -> CREATE VALUE <variableDeclarator>
					<variableDeclaratorId>
						<identifer/>
						<dims/>
					</variableDeclaratorId>
	  	      	     	   </variableDeclarator>
}
FOR VIEW $vVariableDeclarator IN $view
MATCHING SOURCE BY $sVariableDeclarator/variableDeclaratorId/identifier/text() VIEW BY $vVariableDeclarator/variableDeclaratorId/identifeir/text()

PROCEDURE updateVariableDeclarator(source $src AS s:variableDeclarator, view $view AS v:variableDeclarator) =
UPDATE viaraitleDeclarator[$sVariableDeclaratorId AS s:variableDeclaratorId, $sVariableInitializer AS s:variableInitializer?] IN $src BY
{
	updateVariableDeclaratorId($sVariableDeclaratorId, $vVariableDeclaratorId)
	updateVariableInitializerQ($sVariableInitializer, $vVariableInitializer)
}
FOR VIEW variableDeclarator[$vVariableDeclaratorId AS v:variableDeclaratorId, $vVariableInitializer AS v:variableInitializer?] IN $view

PROCEDURE updateVariableDeclaratorId(source $src AS s:variableDeclaratorId, view $view AS v:variableDeclaratorId) =
UPDATE variableDeclaratorId[$sIdentifier AS s:identifier, $sDims AS s:dims] IN $src BY
{
	updateIdentifier($sIdentifier, $vIdentifier);
	updateDims($sDims, $vDims)
}
FOR VIEW variableDeclaratorId[$vIdentifier AS v:identifier, $vDims AS v:dims] IN $view

PROCEDURE updateVariableInitializerQ(source $src AS s:variableInitializer?, view $view AS v:variableInitializer?) =
UPDATE $sVariableInitializer IN $src BY
{
	MATCH -> updateVariableInitializer($sVariableInitializer, $vVariableInitializer)
	| UNMATCHV -> CREATE VALUE <variableInitializer>
				    <expression>
				     <assignmentExpression>
				      <conditionalExpression>
	    			       <conditionalOrExpression>
	     			        <conditionalAndExpression>
	      			         <inclusiveOrExpression>
	       				  <exclusiveOrExpression>
	        			   <andExpression>
	         			    <equalityExpression>
		  			     <relationalExpression>
		   			      <shiftExpression>
		    			       <additiveExpression>	
		     			        <mutiplicativeExpression>
		      			         <unaryExpression>
		       				  <unaryExpressionNotPlusMinus>
		        			   <postfixExpression>
			 			    <expressionName>
			  			     <identifier/>
			 			    </expressionName>
						   </postfixExpression>
		       				  </unaryExpressionNotPlusMinus>
		      				 </unaryExpression>
		     			        </mutiplicativeExpression>
		    			       </additiveExpression>
		   			      </shiftExpression>
		  			     </ralationalExpression>
	         			    </equalityExpression>
					   </andExpression>
	       				  </exclusiveOrExpression>
	      				 </inclusiveOrExpression>
	     			        </conditionalAndExpression>
	    			       </conditionalOrExpression>
	   			      </conditionalExpression>
	  			     </assignmentExpression>
	 			    </expression>
		    	   	   </variableInitializer>
}
FOR VIEW $vVariableInitializer IN $view 

PROCEDURE updateVariableInitializer(source $src AS s:variableInitializer, view $view AS v:variableInitializer) =
UPDATE variableInitializer[$sVI AS (s:expression | s:arrayInitializer)] IN $src BY
{
	CASE $vVI OF
	{
		$vExpression AS v:expression
		-> CASE $sVI OF
		{
			$sExpression AS s:expression
			-> updateExpression($sExpression, $vExpression)
			| $sArrayInitializer AS s:arayInitilizer
			-> DELETE . ;
			CREATE VALUE <variableInitializer>
				      <expression>
				       <assignmentExpression>
				        <conditionalExpression>
	    			         <conditionalOrExpression>
	     			          <conditionalAndExpression>
	      			           <inclusiveOrExpression>
	       				    <exclusiveOrExpression>
	        			     <andExpression>
	         			      <equalityExpression>
		  			       <relationalExpression>
		   			        <shiftExpression>
		    			         <additiveExpression>	
		     			          <mutiplicativeExpression>
		      			           <unaryExpression>
		       				    <unaryExpressionNotPlusMinus>
		        			     <postfixExpression>
			 			      <expressionName>
			  			       <identifier/>
			 			      </expressionName>
						     </postfixExpression>
		       				    </unaryExpressionNotPlusMinus>
		      				   </unaryExpression>
		     			          </mutiplicativeExpression>
		    			         </additiveExpression>
		   			        </shiftExpression>
		  			       </ralationalExpression>
	         			      </equalityExpression>
					     </andExpression>
	       				    </exclusiveOrExpression>
	      				   </inclusiveOrExpression>
	     			          </conditionalAndExpression>
	    			         </conditionalOrExpression>
	   			        </conditionalExpression>
	  			       </assignmentExpression>
	 			      </expression>
		    	   	     </variableInitializer>
		}
		$vArrayInitializer AS v:arrayInitializer
		-> CASE $sVI OF
		{
			$sArrayInitializer AS s:arrayInitilizer
			-> updateArrayInitializer($sArrayInitializer, $vArrayInitializer)
			| $sExpression AS s:expression
			-> DELETE . ;
			CREATE <variableInitializer>
				<arrayInitializer>
				</arrayInitializer>
			       </variableInitializer>
		}
	}
}
FOR VIEW variableInitializer[$vVI AS (v:expression | v:arrayInitializer)] IN $view

PROCEDURE updateMethodDeclaration(source $src AS s:methodDeclaration, view $view AS v:methodDeclaration) =
UPDATE methodDeclaration[$sMethodHeader AS s:methodHeader, $sMethodBody AS s:methodBody] IN $src BY
{
	updateMethodHeader($sMethodHeader, $vMethodHeader);
	updateMethodBody($sMethodBody, $vMethodBody)
}
FOR VIEW methodDeclaration[$vMethodHeader AS s:method] IN $view

PROCEDURE updateMethodHeader(source $src AS s:methodHeader, view $view AS v:methodHeader) =
UPDATE methodHeader[$sMethodModifiers AS s:MethodModifier*, $sResultType AS s:resultType, $sMethodDeclarator AS s:methodDeclarator, $sThrows AS s:throws?] IN $src BY
{
	updateMethodModifiers($sMethodModifiers, $vMethodModifiers);
	updateResultType($sResultType, $vResultType);
	updateMethodDeclarator($sMethodDeclarator, $vMethodDeclarator);
	updateThrowsQ($sThrows, $vThrows)
}
FOR VIEW methodHeader[$vMethodModifiers AS v:MethodModifier*, $vResultType AS v:resultType, $vMethodDeclarator AS v:methodDeclarator, $vThrows AS v:throws?] IN $view 

PROCEDURE updateMethodModifiers(source $src AS s:MethodModifier*, view $view AS v:MethodModifier*) =
UPDATE $sModifier IN $src BY
{
	UNMATCHV -> CREATE VALUE <MethodModifier/>
}
FOR VIEW $vModifier IN $view
MATCHING SOURCE BY $sModifier/text() VIEW BY $vModifier/text()

PROCEDURE updateResultType(source $src AS s:resultType, view $view AS v:resultType) =
UPDATE resultType[$sRTp AS (s:tp | s:voidType)] IN $src BY
{
	CASE $vRTp OF
	{
		$vTp AS v:tp -> CASE $sRTp OF
		{
			$sTp AS s:tp -> updateTp($sTp, $vTp)
			| $sVoid AS s:voidType -> DELETE .;
			  	    	       	  CREATE VALUE <resultType>{$vTp}</resultType>
		}
		| $vVoid AS v:voidType -> CASE $sRTp OF
		{
			$sTp AS s:tp -> DELETE . ;
			     	     	CREATE VALUE <resultType>{$vVoid}</resultType>
			| $sVoid AS s:voidType -> updateString($sVoid/text(), $vVoid/text())
		}
	}
}
FOR VIEW resultType[$vRTp AS (v:tp | v:voidType)] IN $view

PROCEDURE updateMethodDeclarator(source $src AS s:methodDeclarator, view $view AS v:methodDeclarator) =
UPDATE methodDeclarator[$sIdentifier AS s:identifier, $sFormalParameters AS s:formalParameter*] IN $src BY
{
	updateIdentifier($sIdentifier, $vIdentifier);
	updateFormalParameters($sFormalParameters, $vFormalParameters)
}
FOR VIEW methodDeclarator[$vIdnetifier AS v:identifier, $vFormalParameters AS v:formalParameter*] IN $view 

PROCEDURE updateMethodBody(source $src AS s:methodBody, view $view AS v:methodBody) =
UPDATE methodBody[$sBlock AS s:block?] IN $src BY
{
	updateBlockQ($sBlock, $vBlock)
}
FOR VIEW methodBody[$vBlock AS v:block?] IN $view

PROCEDURE updateBlockQ(source $src AS s:block?, view $view AS v:block?) =
UPDATE $sBlock IN $src BY
{
	MATCH -> updateBlock($sBlock, $vBlock)
	| UNMATCHV -> CREATE VALUE <block></block>
}
FOR VIEW $vBlock IN $view 

PROCEDURE updateInterfaceDeclaration(source $src AS s:interfaceDeclaration, view $view AS v:interfaceDeclaration) =
UPDATE interfaceDeclaration[$sInterfaceModifiers AS s:interfaceModifier*, $sIdentifier AS s:identifier, $sExtendsInterfaces AS s:extendsInterfaces?, $sInterfaceBody AS s:interfaceBody] IN $src BY
{
	updateInterfaceModifiers($sInterfaceModifiers, $vInterfaceModifiers);
	updateIdentifier($sIdentifier, $vIdentifier);
	updateExtendsInterfacesQ($sExtendsInterfaces, $vExtendsInterfaces);
	updateInterfaceBody($sInterfaceBody, $vInterfaceBody)
}
FOR VIEW interfaceDeclaration[$vInterfaceModifiers AS v:interfaceModifier*, $vIdentifier AS v:idnetifier, $vExtendsInterfaces AS v:extendsInterfaces?, $vInterfaceBody AS v:interfaceBody] IN $view

PROCEDURE updateInterfaceModifiers(source $src AS s:InterfaceModifier*, view $view AS v:interfaceModifier*) =
UPDATE $sModifier IN $src BY
{
	UNMATCHV -> CREATE VALUE <interfaceModifier/>
}
FOR VIEW $vModifier IN $view
MATCHING SOURCE BY $sModifier/text() VIEW BY $vModifier/text()

PROCEDURE updateExtendsInterfacesQ(source $src AS s:extendsInterfaces?, view $view AS v:extendsInterfaces?) =
UPDATE $sEIs IN $src BY
{
	MATCH -> updateExtendsInterfaces($sEIs, $vEIs)
	| UNMATCHV -> CREATE VALUE <extendsInterfaces>
					<interfaceType>
						<typeName>
							<identifier/>
						</typeName>
					</interfaceType>
	  	      	     	   </extendsInterfaces>
}
FOR VIEW $vEIs IN $view

PROCEDURE updateExtendsInterfaces(source $src AS s:extendsInterfaces, view $view AS v:extendsInterfaces) =
UPDATE extendsInterfaces[$sInterfaceTypes AS s:interfaceType+] IN $src BY
{
	updateInterfaceTypes($sInterfaceTypes, $vInterfaceTypes)
}
FOR VIEW extendsInterfaces[$vInterfaceTypes AS v:interfaceType+] IN VIEW

PROCEDURE updateInterfaceTypes(source $src AS s:interfaceType+, view $view AS v:interfaceType+) =
UPDATE $sIT IN $src BY
{
	MATCH -> updateInterfaceType($sIT, $vIT)
	| UNMATCHV -> CREATE VALUE <interfaceType>
					<typeName>
						<identifier/>
					</typeName>
	  	      	     	   </interfaceType>
}
FOR VIEW $vIT IN $view
MATCHING SOURCE BY $sIT/typeName/identifier VIEW BY $vIT/typeName/identifier

PROCEDURE updateInterfaceBody(source $src s:interfaceBody, view $view v:interfaceBody) =
UPDATE interfaceBody[$sInterfaceMemberDeclarations AS s:interfaceMemberDeclaration*] IN $src BY
{
	updateInterfaceMemberDeclarations($sInterfaceMemberDeclarations, $vInterfaceMemberDeclarations)
}
FOR VIEW interfaceBody[$vInterfaceMemberDeclaraions AS v:interfaceMenberDeclaration*] IN $view



PROCEDURE updateInterfaceMemberDeclarations(source $src AS s:interfaceMemberDeclaration*, view $view AS v:interfaceMemberDeclaration*) =
UPDATE $sIFD IN $src BY
{
	MATCH -> CASE $vIFD OF
	{
		$vConstantDeclaration AS v:constantDeclaration 
		-> CASE $sIFD OF
		{
			$sConstantDeclaration AS s:constantDeclaration
			-> updateConstantDeclaration($sConstantDeclaration, $vConstantDeclaration)
		}
		| $vAbstractMethodDeclaration AS v:abstractMethodDeclaration
		-> CASE $sIFD OF
		{
			$sAbstractMethodDeclaration AS s:abstractMethodDeclaration
			-> updateAbstractMethodDeclaration($sAbstractMethodDeclaration, $vAbstractMethodDeclaration)
		}
	}
	| UNMATCHV -> CASE $vIFD OF
	{
		v:constantDeclaration -> CREATE VALUE <interfaceMemberDeclaration id = "">
				      	 	      	<constantDeclaration>
							 <constantModifiers/>
							 <tp>
							  <primitiveType>
							   <identifier/>
							  </primitiveType>
							 </tp>
							 <variableDeclarator>
							  <variableDeclaratorId>
							   <identifier/>
							   <dims/>
							  </variableDeclaratorId>
							 </variableDeclarator>
							</constantDeclaration>
	  	      	     	      	 	      </interfaceMemberDeclaration>
		| v:abstractMethodDeclaration -> CREATE VALUE <interfaceMemberDeclaration>
		  			      	 	       <abstractDeclaration>
							        <resultType>
								 <voidType/>
								</resultType>
								<methodDeclarator>
								 <identifier/>
								</methodDeclarator>
							       </abstractDeclaration>
		  			      	 	      </interfaceMemberDeclaration>
	}
}
FOR VIEW $vIFD IN $view
MATCHING SOURCE BY $sIFD/@id/string() VIEW BY $vIFD/@id/string() 

PROCEDURE updateConstantDeclaration(source $src AS s:constantDeclaration, view $view AS v:constantDeclaration) =
UPDATE constantDeclaration[$sConstantModifiers AS s:constantModifiers, $sTp AS s:tp, $sVariableDeclarator AS s:variableDeclarator] IN $src BY
{
	updateString($sConstantModifiers/text(), $vConstantModifiers/text());
	updateTp($sTp, $vTp);
	updateVariableDeclarator($sVariableDeclarator, $vVariableDeclarator)
}
FOR VIEW constantDeclaration[$vConstantModifiers AS v:constantModifiers, $vTp AS v:tp, $vVariableDeclarator As v:variableDeclarator] IN $view

PROCEDURE updateAbstractMethodDeclaration(source $src AS s:abstractMethodDeclaration, view $view AS v:abstractMethodDeclaration) =
UPDATE abstractMethodDeclaration[$sAbstractMethodModifiers AS s:abstractMethodModifier*, $sResultType AS s:resultType, $sMethodDeclarator AS s:methodDeclarator, $sThrows AS s:throws?] IN $src BY
{
	updateAbstractMethodModifers($sAbstractMethodModifiers, $vAbstractMethodModifiers);
	updateResultType($sResultType, $vResultType);
	updateMethodDeclarator($sMethodDeclarator, $vMethodDeclarator);
	updateThrowsQ($sThrows, $vThrows)
}
FOR VIEW abstractMethodDeclaration[$vAbstractMethodModifiers AS v:abstractMethodModifier*, $vResultType AS v:resultType, $vMethodDeclarator AS v:methodDeclarator, $vThrows AS v:throws?] IN VIEW

PROCEDURE updateAbstractMethodModifiers(source $src AS s:abstractMethodModifier*, view $view AS v:abstractMethodModifier*) =
UPDATE $sModifier IN $src BY
{
	UNMATCHV -> CREATE VALUE <abstractMethodModifier/>
}
FOR VIEW $vModifier IN $view
MATCHING SOURCE BY $sModifier/text() VIEW BY $vModifier/text()

PROCEDURE updateArrayInitializer(source $src AS s:arrayInitializer, view $view AS v:arrayInitializer) =
UPDATE arrayInitializer[$sVariableInitializers AS s:variableInitializer*] IN $src BY
{
	updateVariableInitializers($sVariableInitializers, $vVariableInitializers)
}
FOR arrayInitializer[$vVariableInitializers AS v:variableInitializer*]

PROCEDURE updateVariableInitializers(source $src s:variableInitializer*, view $view v:variableInitializer*) =
update $sVI IN $src BY
{
	MATCH -> updateVariableInitializer($sVI, $vVI)
	| UNMATCHV -> CREATE VALUE <variableInitializer>
					<arrayInitilizer>
					</arrayInitilizer>
	  	      	     	   </variableInitializer>
}
FOR VIEW $vVI IN $view

(:-----------------------------Types------------------------------:)

PROCEDURE updateTp(source $src AS s:tp, view $view AS v:tp) =
UPDATE tp[$sTp AS (s:primitiveType | s:referenceType)] IN $src BY
{
	CASE $vTp OF
 	{
		$vPrimitiveType AS v:primitiveType
		-> CASE $sTp OF
		{
			$sPrimitiveType AS s:primitiveType
			-> updatePrimitiveType($sPrimitiveType, $vPrimitiveType)
			| sReferenceType AS s:referenceType
			-> DELETE . ;
			CREATE VALUE <tp>
					{$vPrimitiveType}
			       	     </tp>
		}
		| $vReferenceType AS v:referenceType
		-> CASE $sTp OF
		{
			$sPrimitiveType AS s:primitiveType
			-> DELETE . ;
			CREATE VALUE <tp>
					{$vReferenceType}
				     </tp>
			| $sReferenceType AS v:referenceType
			-> updateReferenceType($sReferenceType, $vReferenceType)
		}
	}
}
FOR VIEW tp[$vTp AS (v:primitiveType | s:referenceType)] IN $view

PROCEDURE updatePrimitiveType(source $src AS s:primitiveType, view $view AS v:primitiveType) =
updateString($src/text(), $view/text())

PROCEDURE updateReferenceType(source $src AS s:referenceType, view $view AS v:referenceType) =
UPDATE referenceType[$sRT AS (s:arrayType | s:classType | s:interfaceType)] IN $src BY
{
	CASE $vRT OF
	{
		$vArrayType AS v:arrayType
		-> CASE $sRT OF
		{
			$sArrayType AS s:arrayType
			-> updateArrayType($sArrayType, $vArrayType)
			| $sClassType AS s:classType
			-> DELETE
		}
	}
}
FOR VIEW referenceType[$vRT AS (v:arrayType | v:classType | v:interfaceType)] IN $view



 
PROCEDURE updatePackageName(source $src AS s:packageName, view $view AS v:packageName) =
UPDATE packageName[$sIdentifiers AS s:identifier+] IN $src BY
{

}

PROCEDURE updateString(source $src AS String, view $view AS String) =
UPDATE $sString IN $src BY
{
	REPLACE . WITH $vString
}
FOR VIEW $vString IN $view